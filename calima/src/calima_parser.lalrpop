use crate::ast_common::{Literal, NumberType, MatchPattern, BindPattern, Identifier};
use crate::ast::{Block, Statement, Expr, TypeDefinition, TypeAnnotation, Modifier, RegionAnnotation, RegionVariable, GenericTypeKind, TypeKind, TopLevelBlock, TopLevelStatement};
use crate::token::{Location, Token, NumberFormat};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input, Data, F>(to_data: &F) where F: Fn(Location, Location) -> Data;

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<(&'input str, NumberFormat)>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "in" => In,
        "let" => Let,
        "rec" => Rec,
        "_" => Underscore,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow,
        "and" => And,
        "backtick" => Backtick,
        "@" => At,
        "'" => Apostrophe
    }
}

Sep1<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Sep2<T, S>: Vec<T> = {
    <v:(<T> S)+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Combine<S, T>: (S, T) = {
    <s:S> <t:T> => (s, t)
};

Sep1Collect<T, S>: (Vec<T>, Vec<S>) = {
    <t1: T> <r:(Combine<S, T>)+> => {
        let mut ts = Vec::new();
        let mut ss = Vec::new();
        ts.push(t1);
        for (s, t) in r {
            ts.push(t);
            ss.push(s);
        }
        (ts, ss)
    }
};

pub TopLevelBlock: TopLevelBlock<'input, Data> = {
    <top_levels:TopLevelStatement+> "in" <block:Block> => TopLevelBlock { top_levels, block },
    <Block> => TopLevelBlock { top_levels: Vec::new(), block: <> }
};

Block: Block<'input, Data> = {
    <sts:Statement+> "in" <e:Expression0> => Block {
        statements: sts,
        result: Box::new(e)
    },
    <e: Expression0> => Block {
        statements: Vec::new(),
        result: Box::new(e)
    }
};

TopLevelStatement: TopLevelStatement<'input, Data> = {
    Import,
    <posl:@L> "type" <n:"typename"> <regions:RegionVariable*> <params:GenericTypeKind*> "=" <td:TypeDefinition> <posr:@R> => TopLevelStatement::Type { name: n, regions, params, type_def: td, data: to_data(posl, posr) },
};

Import: TopLevelStatement<'input, Data> = {
    <posl:@L> "import" <m:Sep1<AnyName, ".">> <posr:@R> => TopLevelStatement::Import(m, Vec::new(), to_data(posl, posr)),
    <posl:@L> "import" <m:Sep1<AnyName, ".">> "{" <f:Sep1<Identifier, ",">> "}" <posr:@R> => TopLevelStatement::Import(m, f, to_data(posl, posr))
};

Statement: Statement<'input, Data> = {
    Let,
    Do,
    Region
};

Region: Statement<'input, Data> = <posl:@L> "region" <n:RegionAnnotation> <posr:@R> => Statement::Region(n, to_data(posl, posr));

Do: Statement<'input, Data> = <posl:@L> "do" <e:Expression0> <posr:@R> => Statement::Do(e, to_data(posl, posr));

Let: Statement<'input, Data> = <posl:@L> "let" <mods:Modifiers> <pat:BindPattern0> "=" <expr:Expression0> <posr:@R> => Statement::Let(mods, pat, expr, to_data(posl, posr));

Modifiers: Vec<Modifier> = Modifier*;

Modifier: Modifier = {
    "rec" => Modifier::Rec
};

Expression0: Expr<'input, Data> = {
    If,
    Case,
    Expression1
};

Case: Expr<'input, Data> = <posl:@L> "case" <value_expr:Expression1> "of" <rows:CaseRow+> "end" <posr:@R> => Expr::Case {
    data: to_data(posl, posr),
    value: Box::new(value_expr),
    matches: rows
};

CaseRow: (MatchPattern<'input, TypeAnnotation<'input, Data>, Data>, Block<'input, Data>) = "|" <pat:MatchPattern0> "->" <block:Block> => (pat, block);

If: Expr<'input, Data> = <posl:@L> "if" <cond_expr:Expression1> "then" <if_block:Block> "else" <else_block:Block> "end" <posr:@R> => Expr::If {
    data: to_data(posl, posr),
    cond: Box::new(cond_expr),
    if_true: if_block,
    if_false: else_block
};

Expression1: Expr<'input, Data> = {
    FunctionCall,
    OperatorCall,
    UnaryOperatorCall,
    Lambda,
    Expression2
};

RecordExprRow: (&'input str, Expr<'input, Data>) = <n:"name"> "=" <expr:Expression0> => (n, expr);

Lambda: Expr<'input, Data> = <posl:@L> "fun" <regions:RegionAnnotation*> <params:BindPattern0+>  "->" <block:Block> <posr:@R> => Expr::Lambda { regions, params, body: block, data: to_data(posl, posr) };

FunctionCall: Expr<'input, Data> = <posl:@L> <func:Expression2> <args:Expression2+> <posr:@R> => Expr::FunctionCall(Box::new(func), args, to_data(posl, posr));

UnaryOperatorCall: Expr<'input, Data> = <posl:@L> <op:"operator"> <expr:Expression2> <posr:@R> => Expr::UnaryOperatorCall(op, Box::new(expr), to_data(posl, posr));

OperatorCall: Expr<'input, Data> = <posl:@L> <r:Sep1Collect<Expression2, "operator">> <posr:@R> => Expr::OperatorCall(r.0, r.1, to_data(posl, posr));

Expression2: Expr<'input, Data> = {
    Variable,
    OperatorAsFunction,
    LiteralExpr,
    TupleConstruct,
    "(" <Expression0> ")" => <>,
    <posl:@L> "[" <exprs: Sep1<Expression0, ",">> "]" <posr:@R> => Expr::List(exprs, to_data(posl, posr)),
    <posl:@L> "{" <rows: Sep1<RecordExprRow, ",">> "}" <posr:@R> => Expr::Record(rows, to_data(posl, posr)),
};

OperatorAsFunction: Expr<'input, Data> = <posl:@L> "backtick" <op:"operator"> "backtick" <posr:@R> => Expr::OperatorAsFunction(op, to_data(posl, posr));

TupleConstruct: Expr<'input, Data> = <posl:@L> "(" <exprs:Sep2<Expression1, ",">> ")" <posr:@R> => Expr::Tuple(exprs, to_data(posl, posr));

Variable: Expr<'input, Data> = <posl:@L> <elements:Sep1<AnyName, ".">> <posr:@R> => Expr::Variable(elements, to_data(posl, posr));

AnyName: &'input str = {
    <"name"> => <>,
    <"typename"> => <>
};

LiteralExpr: Expr<'input, Data> = <posl:@L> <lit:Literal> <posr:@R> => Expr::Literal(lit, to_data(posl, posr));

RecordBindPatternRow: (&'input str, BindPattern<'input, TypeAnnotation<'input, Data>, Data>) = <name:"name"> "=" <patt:BindPattern0> => (name, patt);

BindPattern0: BindPattern<'input, TypeAnnotation<'input, Data>, Data> = {
    <posl:@L> "_" <posr:@R> => BindPattern::Any(to_data(posl, posr)),
    <posl:@L> <id:AnnotatedIdentifier> <posr:@R> => BindPattern::Name(id.0, id.1, to_data(posl, posr)),
    "(" <BindPattern0> ")" => <>,
    <posl:@L> "{" <rows:Sep1<RecordBindPatternRow, ",">> "}" <posr:@R> => BindPattern::Record(rows, to_data(posl, posr)),
    <posl:@L> "(" <elements:Sep2<BindPattern0, ",">> ")" <posr:@R> => BindPattern::Tuple(elements, to_data(posl, posr))
};

MatchPattern0: MatchPattern<'input, TypeAnnotation<'input, Data>, Data> = {
    MatchPattern1,
    <posl:@L> <variant:"typename"> <patt:MatchPattern1?> <posr:@R> => MatchPattern::SumUnwrap(variant, patt.map(|p| Box::new(p)), to_data(posl, posr)),
};

RecordMatchPatternRow: (&'input str, MatchPattern<'input, TypeAnnotation<'input, Data>, Data>) = <name:"name"> "=" <patt:MatchPattern1> => (name, patt);

MatchPattern1: MatchPattern<'input, TypeAnnotation<'input, Data>, Data> = {
    <posl:@L> "_" <posr:@R> => MatchPattern::Any(to_data(posl, posr)),
    <posl:@L> <id:AnnotatedIdentifier> <posr:@R> => MatchPattern::Name(id.0, id.1, to_data(posl, posr)),
    <posl:@L> <lit:Literal> <posr:@R> => MatchPattern::Literal(lit, to_data(posl, posr)),
    "(" <MatchPattern0> ")" => <>,
    <posl:@L> "{" <rows:Sep1<RecordMatchPatternRow, ",">> "}" <posr:@R> => MatchPattern::Record(rows, to_data(posl, posr)),
    <posl:@L> "(" <elements:Sep2<MatchPattern1, ",">> ")" <posr:@R> => MatchPattern::Tuple(elements, to_data(posl, posr))
};

AnnotatedIdentifier: (Identifier<'input, Data>, Option<TypeAnnotation<'input, Data>>) = {
    <Identifier> => (<>, None),
    "(" <ident:Identifier> ":" <ta:TypeAnnotation0> ")" => (ident, Some(ta))
};

Identifier: Identifier<'input, Data> = {
    <posl:@L> <n:"name"> <posr:@R> => Identifier::Simple(n, to_data(posl, posr)),
    <posl:@L> "(" <n:"operator"> ")" <posr:@R> => Identifier::Operator(n, to_data(posl, posr)),
};

TypeDefinition: TypeDefinition<'input, Data> = {
    <TypeAnnotation0> => TypeDefinition::Alias(<>),
    Sum,
    "{" <Sep1<RecordTypeRow, ",">> "}" => TypeDefinition::Record(<>)
};

Sum: TypeDefinition<'input, Data> = "|" <Sep1<SumRow, "|">> => TypeDefinition::Sum(<>);

SumRow: (&'input str, Option<TypeAnnotation<'input, Data>>) = {
    <n:"typename"> <ta:TypeAnnotation1?> => (n, ta)
};

RecordTypeRow: (&'input str, TypeAnnotation<'input, Data>) = <n:"name"> ":" <ta:TypeAnnotation0> => (n, ta);

TypeAnnotation0: TypeAnnotation<'input, Data> = {
    <posl:@L> <reg:RegionAnnotation> <tk:TypeKind1> <posr:@R> => TypeAnnotation(Some(reg), tk, to_data(posl, posr)),
    <posl:@L> <tk:TypeKind0> <posr:@R> => TypeAnnotation(None, tk, to_data(posl, posr))
};

TypeAnnotation1: TypeAnnotation<'input, Data> = {
    <posl:@L> <reg:RegionAnnotation> <tk:TypeKind1> <posr:@R> => TypeAnnotation(Some(reg), tk, to_data(posl, posr)),
    <posl:@L> <tk:TypeKind1> <posr:@R> => TypeAnnotation(None, tk, to_data(posl, posr))
};

TypeKind0: TypeKind<'input, Data> = {
    <inp:TypeAnnotation1> "->" <out:TypeAnnotation0> => TypeKind::Function(Box::new(inp), Box::new(out)),
    <n:Sep1<"typename", "and">> <params:TypeAnnotation1+> => TypeKind::Parameterized(n, params),
    TypeKind1
};

TypeKind1: TypeKind<'input, Data> = {
    <posl:@L> <n:Sep1<"typename", "and">> <posr:@R> => TypeKind::Name(n, to_data(posl, posr)),
    <GenericTypeKind> => TypeKind::Generic(<>),
    "(" <Sep2<TypeAnnotation0, ",">> ")" => TypeKind::Tuple(<>),
    "(" <tk:TypeKind0> ")" => tk,
};

GenericTypeKind: GenericTypeKind<'input, Data> = <posl:@L> <n:"name"> <posr:@R> => GenericTypeKind(n, to_data(posl, posr));

RegionAnnotation: RegionAnnotation<'input, Data> = {
    "@" "." => RegionAnnotation::Stack,
    "@" "_" => RegionAnnotation::Anonymous,
    <posl:@L> "@" <n:"name"> <posr:@R> => RegionAnnotation::Named(n, to_data(posl, posr)),
    <RegionVariable> => RegionAnnotation::Var(<>)
};

RegionVariable: RegionVariable<'input, Data> = <posl:@L> "'" <n:"name"> <posr:@R> => RegionVariable(n, to_data(posl, posr));

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <n:"number"> => {
        let nt = match n.1 {
            NumberFormat::Integer => NumberType::Integer,
            NumberFormat::Float => NumberType::Float
        };
        Literal::Number(n.0, nt)
    },
    <"string"> => Literal::String(<>)
};