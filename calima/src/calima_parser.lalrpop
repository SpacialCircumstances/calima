use crate::ast::{Block, Statement, Expr, Literal, NumberType, Pattern, Identifier, TypeDefinition, TypeAnnotation, Modifier, RegionAnnotation, TypeKind, NamedRegion, GenericRegion, ClassDefinition, InstanceDefinition, TopLevelBlock, TopLevelStatement};
use crate::token::{Location, Token};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input, Data, F>(input: &'input str, to_data: &F) where F: Fn(Location, Location) -> Data;

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "regionname" => RegionIdentifier(<&'input str>),
        "genericregion" => GenericRegionIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<&'input str>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "in" => In,
        "let" => Let,
        "rec" => Rec,
        "_" => Underscore,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow,
        "class" => Class,
        "instance" => Instance,
        "and" => And
    }
}

Sep1<T, S>: Vec<T> = { // (1)
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Sep2<T, S>: Vec<T> = { // (1)
    <v:(<T> S)+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub TopLevelBlock: TopLevelBlock<'input, Data> = {
    <top_levels:TopLevelStatement+> "in" <block:Block> => TopLevelBlock { top_levels, block },
    <Block> => TopLevelBlock { top_levels: Vec::new(), block: <> }
};

Block: Block<'input, Data> = {
    <sts:Statement+> "in" <e:Expression0> => Block {
        statements: sts,
        result: Box::new(e)
    },
    <e: Expression0> => Block {
        statements: Vec::new(),
        result: Box::new(e)
    }
};

TopLevelStatement: TopLevelStatement<'input, Data> = {
    Import,
    <posl:@L> "type" <regions:GenericRegion*> <n:"typename"> <params:TypeAnnotation1*> "=" <td:TypeDefinition> <posr:@R> => TopLevelStatement::Type { name: n, regions, params, type_def: td, data: to_data(posl, posr) },
    <posl:@L> "class" <regions:GenericRegion*> <n:"typename"> <params:TypeAnnotation1*> "=" <class_rows:Sep1<ClassRow, ",">> "end" <posr:@R> => TopLevelStatement::Class { name: n, regions, params, class_def: ClassDefinition(class_rows), data: to_data(posl, posr) },
    <posl:@L> "instance" <regions:RegionAnnotation*> <n:"typename"> <args:TypeAnnotation1*> "=" <instance_rows:Sep1<InstanceRow, ",">> "end" <posr:@R> => TopLevelStatement::Instance { name: n, regions, args, instance_def: InstanceDefinition(instance_rows), data: to_data(posl, posr) }
};

ClassRow: (Identifier<'input, Data>, TypeAnnotation<'input, Data>) = <n:Identifier> ":" <ta:TypeAnnotation0> => (n, ta);

InstanceRow: (Identifier<'input, Data>, Expr<'input, Data>) = <n:Identifier> "=" <expr:Expression1> => (n, expr);

Import: TopLevelStatement<'input, Data> = {
    <posl:@L> "import" <m:Sep1<AnyName, ".">> <posr:@R> => TopLevelStatement::Import(m, Vec::new(), to_data(posl, posr)),
    <posl:@L> "import" <m:Sep1<AnyName, ".">> "{" <f:Sep1<Identifier, ",">> "}" <posr:@R> => TopLevelStatement::Import(m, f, to_data(posl, posr))
};

Statement: Statement<'input, Data> = {
    Let,
    Do,
    Region
};

Region: Statement<'input, Data> = <posl:@L> "region" <n:NamedRegion> <posr:@R> => Statement::Region(n, to_data(posl, posr));

Do: Statement<'input, Data> = <posl:@L> "do" <reg:RegionAnnotation?> <e:Expression0> <posr:@R> => Statement::Do(reg, e, to_data(posl, posr));

Let: Statement<'input, Data> = <posl:@L> "let" <mods:Modifiers> <reg:RegionAnnotation?> <pat:Pattern1> "=" <expr:Expression0> <posr:@R> => Statement::Let(mods, reg, pat, expr, to_data(posl, posr));

Modifiers: Vec<Modifier> = Modifier*;

Modifier: Modifier = {
    "rec" => Modifier::Rec
};

Expression0: Expr<'input, Data> = {
    If,
    Case,
    Expression1
};

Case: Expr<'input, Data> = <posl:@L> "case" <value_expr:Expression1> "of" <rows:CaseRow+> "end" <posr:@R> => Expr::Case {
    data: to_data(posl, posr),
    value: Box::new(value_expr),
    matches: rows
};

CaseRow: (Pattern<'input, Data>, Block<'input, Data>) = "|" <pat:Pattern0> "->" <block:Block> => (pat, block);

If: Expr<'input, Data> = <posl:@L> "if" <cond_expr:Expression1> "then" <if_block:Block> "else" <else_block:Block> "end" <posr:@R> => Expr::If {
    data: to_data(posl, posr),
    cond: Box::new(cond_expr),
    if_true: if_block,
    if_false: else_block
};

Expression1: Expr<'input, Data> = {
    FunctionCall,
    OperatorCall,
    Lambda,
    Expression2
};

RecordExprRow: (&'input str, Expr<'input, Data>) = <n:"name"> "=" <expr:Expression0> => (n, expr);

Lambda: Expr<'input, Data> = <posl:@L> "fun" <regions:GenericRegion*> <params:Pattern1+>  "->" <block:Block> <posr:@R> => Expr::Lambda { regions, params, body: block, data: to_data(posl, posr) };

FunctionCall: Expr<'input, Data> = <posl:@L> <func:Expression2> <args:Expression2+> <posr:@R> => Expr::FunctionCall(Box::new(func), args, to_data(posl, posr));

OperatorCall: Expr<'input, Data> = <posl:@L> <f1:Expression2> <op:"operator"> <f2:Expression2> <posr:@R> => Expr::OperatorCall(Box::new(f1), op, Box::new(f2), to_data(posl, posr));

Expression2: Expr<'input, Data> = {
    Variable,
    LiteralExpr,
    TupleConstruct,
    "(" <Expression0> ")" => <>,
    <posl:@L> "[" <exprs: Sep1<Expression0, ",">> "]" <posr:@R> => Expr::List(exprs, to_data(posl, posr)),
    <posl:@L> "{" <rows: Sep1<RecordExprRow, ",">> "}" <posr:@R> => Expr::Record(rows, to_data(posl, posr)),
};

TupleConstruct: Expr<'input, Data> = <posl:@L> "(" <exprs:Sep2<Expression1, ",">> ")" <posr:@R> => Expr::Tuple(exprs, to_data(posl, posr));

Variable: Expr<'input, Data> = <posl:@L> <elements:Sep1<AnyName, ".">> <posr:@R> => Expr::Variable(elements, to_data(posl, posr));

AnyName: &'input str = {
    <"name"> => <>,
    <"typename"> => <>
};

LiteralExpr: Expr<'input, Data> = <posl:@L> <lit:Literal> <posr:@R> => Expr::Literal(lit, to_data(posl, posr));

Pattern0: Pattern<'input, Data> = {
    Pattern1,
    <posl:@L> <variant:"typename"> <patt:Pattern1?> <posr:@R> => Pattern::SumUnwrap(variant, patt.map(|p| Box::new(p)), to_data(posl, posr)),
};

RecordPatternRow: (&'input str, Pattern<'input, Data>) = <name:"name"> "=" <patt:Pattern1> => (name, patt);

Pattern1: Pattern<'input, Data> = {
    <posl:@L> "_" <posr:@R> => Pattern::Any(to_data(posl, posr)),
    <posl:@L> <id:AnnotatedIdentifier> <posr:@R> => Pattern::Name(id.0, id.1, to_data(posl, posr)),
    <posl:@L> <lit:Literal> <posr:@R> => Pattern::Literal(lit, to_data(posl, posr)),
    "(" <Pattern0> ")" => <>,
    <posl:@L> "{" <rows:Sep1<RecordPatternRow, ",">> "}" <posr:@R> => Pattern::Record(rows, to_data(posl, posr)),
    <posl:@L> "(" <elements:Sep2<Pattern1, ",">> ")" <posr:@R> => Pattern::Tuple(elements, to_data(posl, posr))
};

AnnotatedIdentifier: (Identifier<'input, Data>, Option<TypeAnnotation<'input, Data>>) = {
    <Identifier> => (<>, None),
    "(" <ident:Identifier> ":" <ta:TypeAnnotation0> ")" => (ident, Some(ta))
};

Identifier: Identifier<'input, Data> = {
    <posl:@L> <n:"name"> <posr:@R> => Identifier::Simple(n, to_data(posl, posr)),
    <posl:@L> "(" <n:"operator"> ")" <posr:@R> => Identifier::Operator(n, to_data(posl, posr)),
};

TypeDefinition: TypeDefinition<'input, Data> = {
    <TypeAnnotation0> => TypeDefinition::Alias(<>),
    Sum,
    "{" <Sep1<RecordTypeRow, ",">> "}" => TypeDefinition::Record(<>)
};

Sum: TypeDefinition<'input, Data> = "|" <Sep1<SumRow, "|">> => TypeDefinition::Sum(<>);

SumRow: (&'input str, Option<TypeAnnotation<'input, Data>>) = {
    <n:"typename"> <ta:TypeAnnotation1?> => (n, ta)
};

RecordTypeRow: (&'input str, TypeAnnotation<'input, Data>) = <n:"name"> ":" <ta:TypeAnnotation0> => (n, ta);

TypeAnnotation0: TypeAnnotation<'input, Data> = {
    <posl:@L> <reg:RegionAnnotation> <tk:TypeKind1> <posr:@R> => TypeAnnotation(Some(reg), tk, to_data(posl, posr)),
    <posl:@L> <tk:TypeKind0> <posr:@R> => TypeAnnotation(None, tk, to_data(posl, posr))
};

TypeAnnotation1: TypeAnnotation<'input, Data> = {
    <posl:@L> <reg:RegionAnnotation> <tk:TypeKind1> <posr:@R> => TypeAnnotation(Some(reg), tk, to_data(posl, posr)),
    <posl:@L> <tk:TypeKind1> <posr:@R> => TypeAnnotation(None, tk, to_data(posl, posr))
};

TypeKind0: TypeKind<'input, Data> = {
    <inp:TypeAnnotation1> "->" <out:TypeAnnotation0> => TypeKind::Function(Box::new(inp), Box::new(out)),
    <n:Sep1<"typename", "and">> <params:TypeAnnotation1+> => TypeKind::Parameterized(n, params),
    TypeKind1
};

TypeKind1: TypeKind<'input, Data> = {
    <posl:@L> <n:Sep1<"typename", "and">> <posr:@R> => TypeKind::Name(n, to_data(posl, posr)),
    <posl:@L> <n:"name"> <posr:@R> => TypeKind::Generic(n, to_data(posl, posr)),
    "(" <Sep2<TypeAnnotation0, ",">> ")" => TypeKind::Tuple(<>),
    "(" <tk:TypeKind0> ")" => tk,
};

RegionAnnotation: RegionAnnotation<'input, Data> = {
    <NamedRegion> => RegionAnnotation::Named(<>),
    <GenericRegion> => RegionAnnotation::Generic(<>)
};

NamedRegion: NamedRegion<'input, Data> = <posl:@L> <n:"regionname"> <posr:@R> => NamedRegion(n, to_data(posl, posr));

GenericRegion: GenericRegion<'input, Data> = <posl:@L> <n:"genericregion"> <posr:@R> => GenericRegion(n, to_data(posl, posr));

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <"number"> => Literal::Number(<>, NumberType::Float), //TODO
    <"string"> => Literal::String(<>)
};