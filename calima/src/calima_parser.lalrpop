use crate::ast::{Block, Statement, Expr, Literal, NumberType, Pattern, Identifier, TypeDefinition, TypeAnnotation};
use crate::token::{Location, Token};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input>(input: &'input str);

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<&'input str>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "in" => In,
        "let" => Let,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow
    }
}

Sep1<T, S>: Vec<T> = { // (1)
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Sep2<T, S>: Vec<T> = { // (1)
    <v:(<T> S)+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Block: Block<'input, Location> = <sts:Statement*> <e:Expression1> => Block {
    statements: sts,
    result: Box::new(e)
};

Statement: Statement<'input, Location> = {
    Let,
    Do,
    Import,
    Region,
    "type" <n:"typename"> "=" <td:TypeDefinition> "in" <pos:@L> => Statement::Type(n, td, pos)
};

Region: Statement<'input, Location> = "region" <n:"name"> <pos:@L> => Statement::Region(n, pos);

Do: Statement<'input, Location> = "do" <e:Expression0> "in" <pos:@L> => Statement::Do(e, pos);

Let: Statement<'input, Location> = "let" <pat:Pattern0> "=" <expr:Expression0> "in" <pos:@L> => Statement::Let(pat, expr, pos);

Import: Statement<'input, Location> = "import" <n:"name"> <pos:@L> => Statement::Import(n, pos);

Expression0: Expr<'input, Location> = {
    Expression1
};

Expression1: Expr<'input, Location> = {
    FunctionCall,
    OperatorCall,
    Expression2
};

FunctionCall: Expr<'input, Location> = <func:Expression2> <args:Expression2+> <pos:@L> => Expr::FunctionCall(Box::new(func), args, pos);

OperatorCall: Expr<'input, Location> = <f1:Expression2> <op:"operator"> <f2:Expression2> <pos:@L> => Expr::OperatorCall(Box::new(f1), op, Box::new(f2), pos);

Expression2: Expr<'input, Location> = {
    Variable,
    LiteralExpr,
    "(" <Expression0> ")" => <>
};

Variable: Expr<'input, Location> = <elements:Sep1<"name", ".">> <pos:@L> => Expr::Variable(elements, pos);

LiteralExpr: Expr<'input, Location> = <lit:Literal> <pos:@L> => Expr::Literal(lit, pos);

Pattern0: Pattern<'input> = {
    Pattern1,
    <variant:"typename"> <patt:Pattern1> => Pattern::UnionUnwrap(variant, Box::new(patt)),
    "{" <Sep1<RecordRow, ",">> "}" => Pattern::Record(<>),
    "(" "|" <Sep1<Pattern1, ",">> "|" ")" => Pattern::Tuple(<>)
};

RecordRow: (&'input str, Pattern<'input>) = <name:"name"> "=" <patt:Pattern0> => (name, patt);

Pattern1: Pattern<'input> = {
    Identifier => Pattern::Name(<>),
    <Literal> => Pattern::Literal(<>),
};

Identifier: Identifier<'input> = {
    <"name"> => Identifier::Simple(<>),
    <n:"name"> ":" <ta:TypeAnnotation0> => Identifier::Annotated(n, ta)
};

TypeDefinition: TypeDefinition<'input> = {
    <TypeAnnotation0> => TypeDefinition::Alias(<>),
    <Sep1<UnionRow, "|">> => TypeDefinition::Union(<>),
    <Sep1<RecordTypeRow, ",">> => TypeDefinition::Record(<>)
};

UnionRow: (&'input str, TypeAnnotation<'input>) = <n:"typename"> <ta:TypeAnnotation0> => (n, ta);

RecordTypeRow: (&'input str, TypeAnnotation<'input>) = <n:"name"> ":" <ta:TypeAnnotation0> => (n, ta);

TypeAnnotation0: TypeAnnotation<'input> = {
    <inp:TypeAnnotation1> "->" <out:TypeAnnotation0> => TypeAnnotation::Function(Box::new(inp), Box::new(out)),
    <n:"typename"> "[" <params:TypeAnnotation1+> "]" => TypeAnnotation::Parameterized(n, params),
    TypeAnnotation1,
};

TypeAnnotation1: TypeAnnotation<'input> = {
    <"typename"> => TypeAnnotation::Name(<>),
    <"name"> => TypeAnnotation::Generic(<>),
    "(" "|" <Sep2<TypeAnnotation0, ",">> "|" ")" => TypeAnnotation::Tuple(<>),
    "(" <ta:TypeAnnotation0> ")" => ta
};

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <"number"> => Literal::Number(<>, NumberType::Float), //TODO
    <"string"> => Literal::String(<>)
};