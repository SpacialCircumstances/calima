use crate::ast::{Block, Statement, Expr, Literal, NumberType};
use crate::token::{Location, Token};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input>(input: &'input str);

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<&'input str>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "let" => Let,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow
    }
}

Sep<T, S>: Vec<T> = { // (1)
    <v:(<T> S)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program: Vec<Statement<'input, Location>> = Import*;

Import: Statement<'input, Location> = "import" <n:"name"> <pos:@L> => Statement::Import(n, pos);

Expression: Expr<'input, Location> = {
    Variable,
    LiteralExpr
};

Variable: Expr<'input, Location> = <elements:Sep<"name", ".">> <pos:@L> => Expr::Variable(elements, pos);

LiteralExpr: Expr<'input, Location> = <lit:Literal> <pos:@L> => Expr::Literal(lit, pos);

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <"number"> => Literal::Number(<>, NumberType::Float),
    <"string"> => Literal::String(<>)
}