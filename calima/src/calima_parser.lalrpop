use crate::ast::{Block, Statement, Expr, Literal, NumberType, Pattern, Identifier, TypeDefinition, TypeAnnotation};
use crate::token::{Location, Token};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input>(input: &'input str);

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<&'input str>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "in" => In,
        "let" => Let,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow
    }
}

Sep1<T, S>: Vec<T> = { // (1)
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Sep2<T, S>: Vec<T> = { // (1)
    <v:(<T> S)+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Block: Block<'input, Location> = <sts:Statement*> <e:Expression1> => Block {
    statements: sts,
    result: Box::new(e)
};

Statement: Statement<'input, Location> = {
    Let,
    Do,
    Import,
    Region,
    "type" <n:"typename"> "=" <td:TypeDefinition> "in" <pos:@L> => Statement::Type(n, td, pos)
};

Region: Statement<'input, Location> = "region" <n:"name"> <pos:@L> => Statement::Region(n, pos);

Do: Statement<'input, Location> = "do" <e:Expression0> "in" <pos:@L> => Statement::Do(e, pos);

//TODO: Consider supporting multiple comma-separated bindings
Let: Statement<'input, Location> = "let" <pat:Pattern0> "=" <expr:Expression0> "in" <pos:@L> => Statement::Let(pat, expr, pos);

Import: Statement<'input, Location> = "import" <n:"name"> <pos:@L> => Statement::Import(n, pos);

Expression0: Expr<'input, Location> = {
    If,
    Expression1
};

Case: Expr<'input, Location> = "case" <value_expr:Expression1> "of" <rows:CaseRow+> "end" <pos:@L> => Expr::Case {
    data: pos,
    value: Box::new(value_expr),
    matches: rows
};

CaseRow: (Pattern<'input>, Block<'input, Location>) = "|" <pat:Pattern0> "->" <block:Block> => (pat, block);

If: Expr<'input, Location> = "if" <cond_expr:Expression1> "then" <if_block:Block> "else" <else_block:Block> "end" <pos:@L> => Expr::If {
    data: pos,
    cond: Box::new(cond_expr),
    if_true: if_block,
    if_false: else_block
};

Expression1: Expr<'input, Location> = {
    FunctionCall,
    OperatorCall,
    TupleConstruct,
    "[" <exprs: Sep1<Expression0, ",">> "]" <pos:@L> => Expr::List(exprs, pos),
    "{" <rows: Sep1<RecordExprRow, ",">> "}" <pos:@L> => Expr::Record(rows, pos),
    Lambda,
    Expression2
};

RecordExprRow: (&'input str, Expr<'input, Location>) = <n:"name"> "=" <expr:Expression0> => (n, expr);

Lambda: Expr<'input, Location> = "fun" <params:Pattern0+>  "->" <block:Block> <pos:@L> => Expr::Lambda(params, block, pos);

TupleConstruct: Expr<'input, Location> = "(" <exprs:Sep2<Expression2, ",">> ")" <pos:@L> => Expr::Tuple(exprs, pos);

FunctionCall: Expr<'input, Location> = <func:Expression2> <args:Expression2+> <pos:@L> => Expr::FunctionCall(Box::new(func), args, pos);

OperatorCall: Expr<'input, Location> = <f1:Expression2> <op:"operator"> <f2:Expression2> <pos:@L> => Expr::OperatorCall(Box::new(f1), op, Box::new(f2), pos);

Expression2: Expr<'input, Location> = {
    Variable,
    LiteralExpr,
    "(" <Expression0> ")" => <>,
};

Variable: Expr<'input, Location> = <elements:Sep1<AnyName, ".">> <pos:@L> => Expr::Variable(elements, pos);

AnyName: &'input str = {
    <"name"> => <>,
    <"typename"> => <>
};

LiteralExpr: Expr<'input, Location> = <lit:Literal> <pos:@L> => Expr::Literal(lit, pos);

Pattern0: Pattern<'input> = {
    Pattern1,
    <variant:"typename"> <patt:Pattern1> => Pattern::UnionUnwrap(variant, Box::new(patt)),
    "{" <Sep1<RecordPatternRow, ",">> "}" => Pattern::Record(<>),
    "(" <Sep2<Pattern1, ",">> ")" => Pattern::Tuple(<>)
};

RecordPatternRow: (&'input str, Pattern<'input>) = <name:"name"> "=" <patt:Pattern0> => (name, patt);

Pattern1: Pattern<'input> = {
    Identifier => Pattern::Name(<>),
    <Literal> => Pattern::Literal(<>),
};

Identifier: Identifier<'input> = {
    <"name"> => Identifier::Simple(<>),
    <n:"name"> ":" <ta:TypeAnnotation1> => Identifier::Annotated(n, ta)
};

TypeDefinition: TypeDefinition<'input> = {
    <TypeAnnotation0> => TypeDefinition::Alias(<>),
    <Sep1<UnionRow, "|">> => TypeDefinition::Union(<>),
    <Sep1<RecordTypeRow, ",">> => TypeDefinition::Record(<>)
};

UnionRow: (&'input str, TypeAnnotation<'input>) = <n:"typename"> "of" <ta:TypeAnnotation0> => (n, ta);

RecordTypeRow: (&'input str, TypeAnnotation<'input>) = <n:"name"> ":" <ta:TypeAnnotation0> => (n, ta);

TypeAnnotation0: TypeAnnotation<'input> = {
    <inp:TypeAnnotation1> "->" <out:TypeAnnotation0> => TypeAnnotation::Function(Box::new(inp), Box::new(out)),
    TypeAnnotation1
};

TypeAnnotation1: TypeAnnotation<'input> = {
    <"typename"> => TypeAnnotation::Name(<>),
    <"name"> => TypeAnnotation::Generic(<>),
    "(" <Sep2<TypeAnnotation0, ",">> ")" => TypeAnnotation::Tuple(<>),
    "(" <ta:TypeAnnotation0> ")" => ta,
    <n:"typename"> "[" <params:TypeAnnotation1+> "]" => TypeAnnotation::Parameterized(n, params)
};

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <"number"> => Literal::Number(<>, NumberType::Float), //TODO
    <"string"> => Literal::String(<>)
};