use crate::ast::{Block, Statement, Expr, Literal, NumberType, Pattern, Identifier};
use crate::token::{Location, Token};
use crate::token::Token::*;
use crate::lexer::Error;

grammar<'input>(input: &'input str);

extern {
    type Location = Location;
    type Error = Error;

    enum Token<'input> {
        "{" => CurlyBraceOpen,
        "}" => CurlyBraceClose,
        "(" => ParenOpen,
        ")" => ParenClose,
        "[" => SquareBracketOpen,
        "]" => SquareBracketClose,
        "." => Period,
        "," => Comma,
        "name" => NameIdentifier(<&'input str>),
        "typename" => TypeIdentifier(<&'input str>),
        "operator" => OperatorIdentifier(<&'input str>),
        "string" => StringLiteral(<&'input str>),
        "number" => NumberLiteral(<&'input str>),
        "bool" => BooleanLiteral(<bool>),
        "do" => Do,
        "in" => In,
        "let" => Let,
        "fun" => Fun,
        "if" => If,
        "then" => Then,
        "else" => Else,
        "case" => Case,
        "of" => Of,
        "end" => End,
        "type" => Type,
        "region" => Region,
        "=" => Equal,
        "|" => Pipe,
        "import" => Import,
        ":" => Colon,
        "->" => Arrow
    }
}

Sep1<T, S>: Vec<T> = { // (1)
    <v:(<T> S)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Block: Block<'input, Location> = <sts:Statement*> <e:Expression0> => Block {
    statements: sts,
    result: Box::new(e)
};

Statement: Statement<'input, Location> = {
    Let,
    Do,
    Import,
    Region
};

Region: Statement<'input, Location> = "region" <n:"name"> <pos:@L> => Statement::Region(n, pos);

Do: Statement<'input, Location> = "do" <e:Expression0> "in" <pos:@L> => Statement::Do(e, pos);

Let: Statement<'input, Location> = "let" <pat:Pattern0> "=" <expr:Expression0> "in" <pos:@L> => Statement::Let(pat, expr, pos);

Import: Statement<'input, Location> = "import" <n:"name"> <pos:@L> => Statement::Import(n, pos);

Expression0: Expr<'input, Location> = {
    FunctionCall,
    Expression1
}

Expression1: Expr<'input, Location> = {
    Variable,
    LiteralExpr
};

FunctionCall: Expr<'input, Location> = <func:Expression1> <args:Expression1+> <pos:@L> => Expr::FunctionCall(Box::new(func), args, pos);

Variable: Expr<'input, Location> = <elements:Sep1<"name", ".">> <pos:@L> => Expr::Variable(elements, pos);

LiteralExpr: Expr<'input, Location> = <lit:Literal> <pos:@L> => Expr::Literal(lit, pos);

Pattern0: Pattern<'input> = {
    Pattern1,
    <variant:"typename"> <patt:Pattern1> => Pattern::UnionUnwrap(variant, Box::new(patt)),
    "{" <Sep1<RecordRow, ",">> "}" => Pattern::Record(<>),
    "(" <Sep1<Pattern1, ",">> ")" => Pattern::Tuple(<>)
};

RecordRow: (&'input str, Pattern<'input>) = <name:"name"> "=" <patt:Pattern0> => (name, patt);

Pattern1: Pattern<'input> = {
    Identifier => Pattern::Name(<>),
    <Literal> => Pattern::Literal(<>),
};

Identifier: Identifier<'input> = {
    <"name"> => Identifier::Simple(<>),
    //TODO: Type annotations
};

Literal: Literal<'input> = {
    "(" ")" => Literal::Unit,
    <"bool"> => Literal::Boolean(<>),
    <"number"> => Literal::Number(<>, NumberType::Float),
    <"string"> => Literal::String(<>)
};